const noop=()=>{},warn=void 0===typeof console?noop:console.warn,isObject=e=>"object"==typeof e&&null!==e,hasOwn$1=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),Provider=e=>t=>(hasOwn$1(e,"store")&&warn("Global app object:store already exists will be covered"),Object.assign({},e,{store:t}));function shallowEqual(e,t){if(e===t)return!0;if(!isObject(e)||!isObject(t))return!1;const n=Object.keys(e),o=Object.keys(t);return n.length===o.length&&!n.some(n=>e[n]!==t[n])}function mergeState(e,t,n,o){let s;if("function"==typeof t)e=t(e),s=Object.keys(e);else{if(!(t instanceof Array))return;s=t.filter(e=>"string"==typeof e)}if(!o){let t;return s.forEach(o=>{shallowEqual(n[o],e[o])||(!t&&(t=Object.create(null)),t[o]=e[o])}),t}s.forEach(t=>{hasOwn$1(n,t)&&warn(`Merge state from store:${t} already exists will be covered`),n[t]=e[t]})}function mergeAction(e,t,n,o){let s;if("function"==typeof t)s=t(e);else{if(!isObject(t))return;s=Object.create(null);for(let n in t)s[n]=((...o)=>e(t[n](...o)))}const c=o.isComponent?n.methods:n;Object.keys(s).forEach(e=>{hasOwn(c,e)&&warn(`Merge action to methods:${e} already exists will be covered`),c[e]=s[e]})}function connect(e,t,n={}){const o=Boolean(e),s=Boolean(t),c=getApp().store;return function(r){const i={ONLOAD:n.isComponent?"attached":"onLoad",ONUNLOAD:n.isComponent?"detached":"onUnload"},{data:a={},[i.ONLOAD]:l,[i.ONUNLOAD]:u}=r;o&&mergeState(c.getState(),e,a,!0),s&&mergeAction(c.dispatch,t,r,n);const f={[i.ONLOAD](t){o&&(this.unsubscribe=c.subscribe(function(){if(!this.unsubscribe)return;const t=mergeState(c.getState(),e,this.data);t&&this.setData(t)}.bind(this))),"function"==typeof l&&l.call(this,t)},[i.ONUNLOAD](){this.unsubscribe&&this.unsubscribe(),"function"==typeof u&&u.call(this)}};return Object.assign({},r,{data:a,...f})}}function connectComponent(e,t){return connect(e,t,{isComponent:!0})}export{Provider,connect,connectComponent};
